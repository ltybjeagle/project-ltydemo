###################################[基础概念]####################################################################
注解说明：
用于类注解：
@EnableEurekaServer：标注为eureka服务端，此应用为注册中心服务端
@EnableDiscoveryClient：标注为eureka客户端，激活eureka注册中心DiscoveryClient对象，可以获取注册中心信息
@LoadBalanced：基于ribbon组件，提供负载均衡策略，默认采用轮训的策略
@EnableCircuitBreaker：标注启用断路器组件
@SpringCloudApplication：注解同@SpringBootApplication、@EnableDiscoveryClient、@EnableCircuitBreaker三个组合功能
@EnableHystrixDashboard：启用断路器仪表盘功能，图表展示服务运行状态
用于函数注解：
@HystrixCommand：标注函数启用断路器，请求失败的话调用配置的默认方法
    注解属性
    fallbackMethod：设置默认方法，函数请求失败会走默认方法，返回默认值
    ignoreExceptions：设置异常信息，函数执行抛出的异常正好是设置的异常信息时，不执行失败补偿方法
    ，并且将异常信息包装成HystrixBadRequestException抛出
    commandKey：设置命令名称
    groupKey：设置命令组，Hystrix默认按命令组分配线程池，同一个组的命令使用一个线程池（默认）
    threadPoolKey：设置线程池名称，同一个线程池名称使用一个线程池（建议使用）
    commandProperties：设置命令属性，集体配置：@HystrixProperty(name ="", value = "")
@CacheResult：必须和@HystrixCommand组合使用，标注命令函数返回的结果被缓存
    注解属性
    cacheKeyMethod：设置缓存key生成策略，配置一个方法实现生成key
@CacheRemove：清楚缓存
    注解属性
    commandKey：命令名称，根据命令名称匹配缓存清除
@HystrixCollapser：合并请求注解，将在一个时间窗口内的同一个命令请求合并成一个批量请求
    注解属性
    batchMethod：批量请求函数
    collapserProperties：属性配置，提供合并注解的过个属性配置
        @HystrixProperty(name ="timerDelayInMilliseconds", value = "100")：设置合并请求时间窗口100毫秒

###################################[eureka注册中心]##############################################################
eureka注册客户端配置:
eureka.client.service-url.defaultZone：注册中心服务地址
eureka.client.registry-fetch-interval-seconds：表示客户端间隔多久去拉取服务器注册信息，默认为30秒
eureka.instance.lease-renewal-interval-in-seconds：客户端每隔多长时间发送心跳，告诉服务器他仍”存活“，默认30秒
eureka.instance.lease-expiration-duration-in-seconds：告诉服务端，客户端多久没有发送心跳，就将客户端剔除掉，默认90秒
eureka.instance.instance-id：实例ID，用于区分同一应用的不同实例（${spring.application.name}:${random.int}//随机数）
eureka.instance.metadata-map：服务元数据信息，可自定义信息，结构：key: value

eureka健康检查可以结合spring-boot-starter-actuator组件来做

###################################[Ribbon负载均衡组件]############################################################
负载均衡逻辑组件：
    1、负载均衡器
    2、健康检查组件，结合eureka注册中心的话，使用eureka注册中心的健康检查机制
    3、负载均衡算法组件
    4、服务列表组件，结合eureka注册中心的话，使用eureka注册中心服务列表机制
    5、服务列表过滤组件
负载均衡器：
    1、属于客户端负载均衡，服务的健康检查结合eureka注册中心实现。
        负载均衡器定时任务定时检查服务是否可用
    2、使用：在RestTemplate上加上注解@LoadBalanced，即可实现负载均衡。
        GET请求：RestTemplate.getForEntity、RestTemplate.getForObject
        POST请求：RestTemplate.postForEntity、RestTemplate.postForObject、RestTemplate.postForLocation
        PUT请求：RestTemplate.put
        DELETE请求：RestTemplate.delete
    3、负载均衡器里维护服务实例列表，服务列表通过eureka注册中心获取。
        定时任务，定时
        服务实例列表：全部服务列表、可用服务列表、不可用服务列表
        均衡器内部组合均衡策略，根据服务名获取具体实例列表，使用策略获取一个实例，实例里包含服务信息（地址、端口等）
        获取实例列表可以使用“区域感知”过滤器：元数据配置区域信息，根据元数据区域信息匹配同区域的服务实例
            例外：如果服务实例达到一些阀值，就停止使用区域感知过滤器
负载均衡策略：
    1、随机
    2、轮训，设置计数器count，控制10次不能获取到服务实例，就结束获取，提示没有服务
    3、轮训重试，设置超时阀值，在阀值内重试获取，超过阀值结束获取，返回空实例
    4、权重轮训，定时任务定时计算权重，根据个实例节点的响应时间计算权重区间
    5、并发负载最优，获取并发最小的实例
    6、过滤清单轮训，在轮训的基础上增加了一层过滤功能
参数配置：
    1、全局配置
    参考：如下配置基于cloud版本1.5.9
    ribbon.NFLoadBalancerRuleClassName: 设置负载均衡策略，如：com.netflix.loadbalancer.RoundRobinRule
    ribbon.ConnectTimeout：设置请求连接的超时时间，如：500
    ribbon.ReadTimeout：设置请求处理的超时时间，如：3000
    ribbon.OkToRetryOnAllOperations：设置对所有请求进行重试，如：true
    ribbon.MaxAutoRetriesNextServer：设置切换其他实例重试次数，如：2
    ribbon.MaxAutoRetries：设置同一实例重试次数，如：1
    2、单个服务配置

###################################[Hystrix断路器]############################################################
调用逻辑：
    1、Hystrix使用命令模式调用服务，实现解耦(异步编程、响应式编程、RxJava)
    2、Hystrix封装了两个命令对象：
        HystrixCommand:
            execute()：同步执行，返回单一结果
            queue()：异步执行，直接返回一个Future对象，其中包含了一个执行结果后要返回的一个结果对象
        HystrixObservableCommand:
            observe()：返回Hot Observable对象,代表对个结果，没有订阅者也要发布事件
            toObservable()：返回Cold Observable对象,代表对个结果，没有订阅者不发布事件
        命令调用实现：最终都是调用toObservable方法执行命令，其他方法在此基础上控制异步、同步调用
                execute()——>queue()——>toObservable()
                queue()——>toObservable()
                observe()——>toObservable()
                toObservable()
    3、Hystrix内部每个命令都对应一个断路器，以实现熔断功能。
        断路器开关（默认10s）：阀值范围内请求总数（默认20）、阀值范围内失败百分比（默认值50）、参数配置强制打开
        断路器关闭：打开时间 + 休眠时间（默认值5s） 是否小于当前时间，是的话尝试请求，如果请求成功，关闭断路器
        ，否则继续打开断路器，等待下次休眠时间在试
    4、Hystrix执行命令方式：线程池隔离、信号量
    5、Hystrix实现的补偿方法参数里，可以增加Throwable e参数，在补偿方法里获取正常调用的异常信息
    6、可以使用缓存提高效率
    7、Hystrix支持在一个时间窗口内将多个请求合并成一个批量请求处理，但是会增加单笔请求的延迟
调用事例：
1、同步调用：
@HystrixCommand
public UserEntity findUserEntityById(String id) {
    return restTemplate.getForObject(url, clazz, String);
}
2、异步调用：
@HystrixCommand
public Future<UserEntity> findUserEntityById(final String id) {
    return new AsyncResult() {
        @Override
        public UserEntity invoke() {
            return restTemplate.getForObject(url, clazz, String);
        }
    };
}
3、响应式调用：
@HystrixCommand
public Observable<UserEntity> findUserEntityById(final String id) {
    return Observable.create(new ObservableOnSubscribe<UserEntity>() {
        @Override
        public void subscribe(ObservableEmitter<UserEntity> observableEmitter) throws Exception {
            try {
                UserEntity user = restTemplate.getForObject(url, clazz, String);
                observableEmitter.onNext(user);
                observableEmitter.onComplete();
            } catch (Exception e) {
                observableEmitter.onError(e);
            }
        }
    });
}
响应模式：
@HystrixCommand(observableExecutionMode = ObservableExecutionMode.EAGER)使用observe()方式执行
@HystrixCommand(observableExecutionMode = ObservableExecutionMode.LAZY)使用toObservable()方式执行